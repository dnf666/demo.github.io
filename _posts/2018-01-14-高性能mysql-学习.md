---
layout:     post
title:      高性能mysql
subtitle:   mysql
date:       2018-01-14
author:     戴林甫
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - mysql
    - 高性能
---

## 1.1 mysql逻辑架构

![image](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1515920441646&di=28b6f12f4b8c457fed3d4ffff4996c0e&imgtype=0&src=http%3A%2F%2Fimages.cnitblog.com%2Fi%2F610272%2F201403%2F181504216774184.jpg)

## 1.2 mysql的并发控制
    mysql并发控制主要在两个层面，服务器层和存储引擎层面
### 1.2.1读写锁
    解决并发控制的经典做法是：通过共享锁（读锁）和排他锁（写锁），写锁会阻塞其他的写锁和读锁
### 1.2.2锁粒度    
    锁的策略就是在安全性和锁的开销之间的平衡性。锁的开销主要有获得锁、检查锁、释放锁，锁的粒度的问题
    
    mysql提供两种粒度的锁：表锁，行级锁
    
    表锁 ：锁住整张表，开销最小，并发处理程度低。服务器和存储引擎都实现
    行级锁：锁住行，开销最大，并发处理程度最高。只实现存储引擎
### 1.3 事务
    事务：一组原子性的sql查询 具有acid特性
    原子性：一个事务是不可分割的最小工作单位，要么整个成功，要么就全部回滚
    一致性：数据库总是从一个一致的状态到另一个一致的状态
    隔离性：在最终提交之前，该事务的操作对其他事务是不可见的
    持久性：所做的修改是永久保存到数据库中的，即使系统崩溃也不会丢失数据
    
    事务增加了系统安全性，但是也造成了数据库需要更强的cpu处理能力，更大的磁盘，更大的内存，
    用户可以选择是否需要事务处理，来提高系统的性能。即使没有事务，也可以用lock table
    为应用提供一定程度的保护
    
### 事务的隔离级别

![images](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1518933373678&di=181bde7b7d401d1bcbdfb22a9c8b2b86&imgtype=jpg&src=http%3A%2F%2Fimages2015.cnblogs.com%2Fblog%2F796066%2F201704%2F796066-20170402181558649-581777223.jpg)

### 死锁

    多个事务相互请求对方锁定的资源，然后两个无限等待下去，形成一个恶性循环

    解决方法是死锁检测和死锁超时机制（达到锁等待超时的上限就放弃锁请求）

#### innodb目前处理死锁的方法

	持有最少行级排他锁的事务回滚



## 第二章 基准测试

#### 基准测试的策略：

	集成式策略：针对整个系统的整体测试；单组件式策略：单独测试MySQL。通			常使用集成式测试

### 测试指标：

    吞吐量：单位时间内的事务处理数。

    响应时间/延迟：用于测试任务的总体时间，通常使用百分百响应时间，或者利用折线图来直观地观察分布情况。

    并发性：MySQL的并发性并不等同于Web服务器的并发性。检测时要关注正在工作中的并发操作，当并发性操作增加时，测试吞吐量是否下降，响应时间是否变长等。

    可扩展性：理想状态为线性扩展，即给系统增加一倍的工作或者一倍的资源，就能够获得两倍的结果，即吞吐量增加一倍。但是现实情况通常达不到要求。能够发现应用瓶颈。



## 第三章：服务器性能剖析

    主要解决三个问题，确认服务器是否达到最佳状态，为什么某条语句执行很慢

	诊断被用户描述成“停顿”，“堆积‘，”卡死“的故障

### 不值得优化的场景：

    1.占响应时间比重很小的sql不值得优化

    2.优化的查询带来的收益比花费的成本低



### B树和B+树

    b树：1、根结点至少有两个子女；

    2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；

    3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ <= k <= m ；

    4、所有的叶子结点都位于同一层。



#### b+树：
    1.基本和b树差不多

	2.每个非叶子节点关键字个数和其儿子树一样多

	3.叶子节点添加了一个指向e'e'e'e'e'e右旁边的叶子节点

 
    

